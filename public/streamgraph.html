<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <title>Streamgraph</title>
  <style>

    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      margin: auto;
      position: relative;
    }

  </style>

  <script src="http://d3js.org/d3.v3.min.js"></script>
</head>
<body>
  <script>
  // Data processing code
  var data = [],
      sampleinterval = 500,
      numberofsamples = 50;

  window.onload = function() {
      var ws = new WebSocket('ws://localhost:8080');

      ws.onmessage = function(event) {
        var msg = JSON.parse(event.data);

        switch(msg.type) {
          case "packet" : window.dispatchEvent(new CustomEvent('packet_received', {"detail": msg.packet})); break;
          case "ip"     : my_ips = msg.ip; break;
        }
      }
    }

  function currentTime() { return new Date().getTime() }

  window.addEventListener('packet_received', function (event) {
    var packet = event.detail;
    data_length = packet.link.ip.tcp.data_bytes;
    
    data.push({"timestamp": currentTime(), "size": data_length});
  }, false);

  // D3 Visualisation code
  var stack = d3.layout.stack().offset("wiggle"),
    my_ips = [];

    var width = window.innerWidth,
    height = window.innerHeight/2;

    var x = d3.scale.linear()
    .domain([0, numberofsamples - 1])
    .range([0, width]);

    var y = d3.scale.linear()
    .domain([0, 2000])
    .range([height, 0]);

    var area = d3.svg.area()
      .interpolate('basis')
      .x(function(d) { return x(d.x); })
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

    var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);
    

      // svg.selectAll("path")
      //   //.data(samples)
      //   .data(stack([[{"x":0,"y":2}, {"x":1,"y":3}, {"x":2,"y":2}, {"x":3,"y":2}]]))
      //   .enter()
      //   .append("path")
      //   .attr("d", area)
      //   .style("fill", "grey");

    d3.timer(function() {
      time = currentTime();
      grouped_data = [];

      d3.nest()
        .key(function(d) { return d.timestamp; })
        .rollup(function(leaves) { return {"size": d3.sum(leaves, function(d) { return d.size; })} })
        .entries(data)
        .forEach(function(elem){ grouped_data[elem.key] = elem.value });

      console.log(grouped_data.length)

      // Make a list of time units, each with a value
      var samples = d3.range(time, time + (numberofsamples * sampleinterval), sampleinterval).map(function(t) { 
        sum = 0;

        for(i = t; i < (t + sampleinterval); i++) {
          if(grouped_data[i]){
            sum += grouped_data[i].size;
          }
        }

        return {"x": t % time, "y": sum};
      });

      // svg.selectAll("path")
      //   .data(stack([samples]))
      //   //.data(stack([[{"x":0,"y":10}, {"x":1,"y":10}, {"x":2,"y":10}, {"x":3,"y":10}]]))
      //   .enter()
      //   .append("path")
      //   .attr("d", area)
      //   .style("fill", "grey");
    });

  </script>
</body>
</html>
